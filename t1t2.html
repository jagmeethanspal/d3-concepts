<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>PTP Synchronization</title>

	<style type="text/css">
		body {
			background-color: #ccc;
			width: 100%;
		}
		#chart {
			background-color: #bbb;
			width: 1000px;
			height: 500px;
			margin: 50px auto;
			border: solid 1px #000;
		}

		svg{
			background-color: #FFF;
		}
		.dot{
			stroke: #000;
			stroke-width: 1px;
		}
		.axis line, .axis path{
			stroke: #bbb;
		}
		.axis text {
			fill: #bbb;
		}
		#tooltip {
			position: absolute;
			background-color: #FFF;
			padding: 20px;
			border: solid 1px #000;
			opacity: 0;
		}
		.axislabel{
			fill: #bbb;
			font: sans-serif;
			font-size: 10px;
		}
	</style>

	<script type="text/javascript" src="https://d3js.org/d3.v6.min.js"></script>
</head>
<body>

	<div id="chart"></div>
	<div id="tooltip"></div>

	<script type="text/javascript">
		var margin=30, width = 1000, height=500, gMargin = 15;
		var lines, tScale, minTime, maxTime;


		var svg = d3.select('#chart')
				.append('svg')
				.attr('width', width + 'px')
				.attr('height', height + 'px');

		d3.csv('t1t2-skew.csv').then(function(data){
			console.log("Scale animation");
			//console.log(data);

			t1MinMax = d3.extent(data,function(d){
				return parseFloat(d.t1);
			});

			t2MinMax = d3.extent(data,function(d){
				return parseFloat(d.t2);
			});

			minTime = t1MinMax[0]<t2MinMax[0]?t1MinMax[0]:t2MinMax[0];
			maxTime = minTime+1; //t1MinMax[1]>t2MinMax[1]?t1MinMax[1]:t2MinMax[1];

			tScale = d3.scaleLinear()
				.domain([minTime, maxTime])
				.range([margin, height-margin])

			lines = svg.selectAll('.dot')
				.data(data)
				.enter()
				.append('line')
				.attr('class', 'dot')
				.style('opacity', 0.3)
				.attr('x1', 100)
				.attr('y1', function(d){
					//console.log(d.t1);
					return tScale(d.t1);
				})
				.attr('x2', 100)
				.attr('y2', function(d){
					return tScale(d.t1);
				});

				lAxis = d3.axisLeft(tScale).ticks(10, "+f");
				lAxisG = svg.append('g')
	                .attr('id', 'lAxis')
	                .attr('class', 'axis');

	            lAxisG.call(lAxis)
	                .attr('transform', 'translate(100,0)');


				rAxis = d3.axisRight(tScale).ticks(10, "+f");
				rAxisG = svg.append('g')
	                .attr('id', 'rAxis')
	                .attr('class', 'axis');

	            rAxisG.call(rAxis)
	                .attr('transform', 'translate(200,0)');

				update();
				
/*
			data=data.sort(function(a,b){
				return a.charles - b.charles;
			});

			xMinMax = d3.extent(data,function(d){
				return parseFloat(d.poor);
			});

			yMinMax = d3.extent(data,function(d){
				return parseFloat(d.rooms);
			});

			rMinMax = d3.extent(data,function(d){
				return parseFloat(d.value);
			});

			xScale = d3.scaleLinear()
				.domain(xMinMax)
				.range([width-margin-gMargin, margin+gMargin]);

			yScale = d3.scaleLinear()
				.domain(yMinMax)
				.range([height-margin-gMargin,margin+gMargin]);


			rScale = d3.scaleLinear()
				.domain(rMinMax)
				.range([2, 10]);

			cScale = d3.scaleOrdinal()
				.domain([0,1])
				.range(['#333','#FF6600'])


			circles = svg.selectAll('.dot')
				.data(data)
				.enter()
				.append('circle')
				.attr('class', 'dot')
				.attr('cx', function(d){
					return xScale(d.poor);
				})
				.attr('cy', function(d){
					return yScale(d.rooms);
				})
				.attr('r', 0)
				.attr('fill', function(d){
					return cScale(d.charles);
				})
				.style('opacity', function(d){
					return d.charles == 1 ? 1:0.5;
				})
				.on('mouseover', function(event, d){
					var info = d.poor;
					const[x,y] = d3.pointer(event);
					d3.select('#tooltip')
						.html(info)
						.style('left', ((x) - 100) + 'px')
						.style('top', ((y) - 100) + 'px')
						.style('opacity', 0.5);
				})
				.on('mouseout', function(d){
					d3.select('#tooltip')
						.style('left', -1000)
						.style('opacity', 0);
				});


            	xAxis = d3.axisBottom(xScale).ticks(0);
            	yAxis = d3.axisLeft(yScale).tickValues([yMinMax[0],yMinMax[1]]);


	            xAxisG = svg.append('g')
	                .attr('id', 'xAxis')
	                .attr('class', 'axis');

	            xAxisG.call(xAxis)
	                .attr('transform', 'translate(0,' + (height-margin) + ')');


	            yAxisG = svg.append('g')
	                .attr('id', 'yAxis')
	                .attr('class', 'axis');

	            yAxisG.call(yAxis)
	                .attr('transform', 'translate(' + margin + ',0)');

	            svg.append('text')
	            	.attr('x', xScale(xMinMax[0]))
	            	.attr('y', yScale(yMinMax[0]) + margin)
	            	.attr('text-anchor', 'middle')
	            	.text('More Wealthy')
	            	.attr('class', 'axislabel');

	            svg.append('text')
	            	.attr('x', xScale(xMinMax[1]))
	            	.attr('y', yScale(yMinMax[0]) + margin)
	            	.attr('text-anchor', 'middle')
	            	.text('Less Wealthy')
	            	.attr('class', 'axislabel');

	            update();
	            */

		});


		function update() {
			lines.transition()
				.delay(function(d,i){
					//return (d.t2-d.t1)*10000*i;
					return i*10;
				})
				.attr('x2', 200)
				.attr('y2', function(d){
					return tScale(d.t2);
				})

			tscale.transition()
				.domain([minTime, function(d){
					var newMax = d.t1>d.t2?d.t1:d.t2;
					maxTime = newMax>maxTime?newMax:maxTime;
					return maxTime;
				}])
		}

	</script>
</body>
</html>
